package main

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
)

const (
	pkgHttp    = "net/http"
	pkgChi     = "github.com/go-chi/chi"
	pkgStrconv = "strconv"
	pkgJson    = "encoding/json"
	pkgLog     = "log"
)

var (
	genRouter         = "ServiceRouter"
	genWrapError      = "wrapError"
	genRouterReceiver = jen.Id("s").Op("*").Id(genRouter)
)

func RenderServiceRouter(filename string, collection *ServiceCollection) error {
	renderer := jen.NewFile(collection.PackageName)
	renderer.HeaderComment("Code generated by flowheater. DO NOT EDIT.")

	for _, part := range []jen.Code{
		renderRouterStruct(collection),
		renderRouterHandler(collection),
		renderErrorHandler(),
		renderRouterEndpoints(collection),
	} {
		renderer.Add(part).Line()
	}

	return renderer.Save(filename)
}

func renderRouterStruct(c *ServiceCollection) jen.Code {
	return jen.
		Comment(genRouter + " is a collection of services that are").Line().
		Comment("orchestrated into a net/http.Handler.").Line().
		Type().
		Id(genRouter).
		StructFunc(func(g *jen.Group) {
			for _, service := range c.Services {
				g.Id(service.TypeName).Op("*").Id(service.TypeName)
			}
		})
}

func renderRouterHandler(c *ServiceCollection) jen.Code {
	return jen.
		Comment("Handler creates a new net/http.Handler for all the").Line().
		Comment("service endpoints.").Line().
		Func().
		Params(genRouterReceiver).
		Id("Handler").
		Params().
		Qual(pkgHttp, "Handler").
		BlockFunc(func(gen *jen.Group) {
			// h := chi.NewRouter()
			gen.Id("h").Op(":=").Qual(pkgChi, "NewRouter").Call()
			gen.Line()

			for _, service := range c.Services {
				gen.Id("h").Dot("Route").CallFunc(renderRouterRegisterService(service))
				gen.Line()
			}

			// return h
			gen.Return(jen.Id("h"))
		})
}

func renderRouterRegisterService(service *Service) func(*jen.Group) {
	return func(gen *jen.Group) {
		gen.Lit(service.Path)
		gen.Func().Params(jen.Id("r").Qual(pkgChi, "Router")).
			BlockFunc(func(g *jen.Group) {
				for _, endpoint := range service.Endpoints {
					m := strings.Title(strings.ToLower(endpoint.HttpMethod))
					g.Id("r").Dot(m).Call(
						jen.Lit(endpoint.Path),
						jen.Id("s").Dot(genWrapError).Call(
							jen.Id("s").Dot(endpoint.WrapperFunc()),
						),
					)
				}
			})
	}
}

func renderErrorHandler() jen.Code {
	return jen.
		Comment(genWrapError + " wraps a handler to conform with http.HandlerFunc.").Line().
		Func().
		Params(genRouterReceiver).
		Id(genWrapError).
		Params(
			jen.Id("fn").
				Func().
				Params(
					jen.Qual(pkgHttp, "ResponseWriter"),
					jen.Op("*").Qual(pkgHttp, "Request"),
				).
				Params(jen.Id("error")),
		).
		Params(jen.Qual(pkgHttp, "HandlerFunc")).
		Block(
			jen.Return().
				Func().
				Params(
					jen.Id("w").Qual(pkgHttp, "ResponseWriter"),
					jen.Id("r").Op("*").Qual(pkgHttp, "Request"),
				).
				Block(
					jen.If(
						jen.Id("err").Op(":=").Id("fn").Call(
							jen.Id("w"),
							jen.Id("r"),
						),
						jen.Id("err").Op("!=").Nil(),
					).Block(
						jen.Qual(pkgLog, "Printf").
							Call(
								jen.Lit("%s %s: %v"),
								jen.Id("r").Dot("Method"),
								jen.Id("r").Dot("URL").Dot("Path"),
								jen.Id("err"),
							),
						jen.Id("w").
							Dot("WriteHeader").
							Call(jen.Qual(pkgHttp, "StatusInternalServerError")),
					),
				),
		)
}

func renderRouterEndpoints(c *ServiceCollection) jen.Code {
	var funcs jen.Statement

	for _, service := range c.Services {
		for _, endpoint := range service.Endpoints {
			funcs.Add(renderEndpointWrapper(endpoint))
		}
	}

	return &funcs
}

func renderEndpointWrapper(endpoint *Endpoint) jen.Code {
	comment := fmt.Sprintf("%s wraps the endpoint %s#%s.",
		endpoint.WrapperFunc(), endpoint.Service.TypeName, endpoint.FuncName)

	// func (s *ServiceRouter) func _handle_<Service>_<Endpoint>(
	//   w http.ResponseWriter,
	//   r *http.Request,
	// ) { ... }
	return jen.
		Comment(comment).Line().
		Func().
		Params(genRouterReceiver).
		Id(endpoint.WrapperFunc()).
		Params(
			jen.Id("w").Qual(pkgHttp, "ResponseWriter"),
			jen.Id("r").Op("*").Qual(pkgHttp, "Request"),
		).
		Params(jen.Id("err").Id("error")).
		BlockFunc(renderEndpointWrapperBody(endpoint)).
		Line()
}

func renderEndpointWrapperBody(endpoint *Endpoint) func(*jen.Group) {
	return func(gen *jen.Group) {
		for _, param := range endpoint.InputParams {
			// param0 := chi.URLParam("<paramName>")
			renderInputParam(gen, param)
		}

		if len(endpoint.InputParams) > 0 {
			gen.Line()
		}

		// s.<Service>.<Endpoint>(<Params>...)
		gen.Id("s").
			Dot(endpoint.Service.TypeName).
			Dot(endpoint.FuncName).
			CallFunc(func(gen *jen.Group) {
				for _, param := range endpoint.InputVars {
					gen.Id(strings.Repeat("&", param.PointerDepth) + param.VarName)
				}
			})

		gen.Return()
	}
}

func renderInputParam(gen *jen.Group, param InputParam) {
	switch param.ParamKind {
	case KindStringParam:
		gen.Id(param.VarName).Op(":=").Qual(pkgChi, "URLParam").Call(
			jen.Id("r"),
			jen.Lit(param.ParamName),
		)

	case KindConvertParam:
		renderConvertParam(gen, param)

	case KindPayloadParam:
		renderPayloadParam(gen, param)
	}
}

func renderConvertParam(gen *jen.Group, param InputParam) {
	switch param.TypeName {
	case "int", "int8", "int16", "int32", "int64":
		tempName := param.VarName + "Int64"

		gen.List(jen.Id(tempName), jen.Id("err")).Op(":=").
			Qual(pkgStrconv, "ParseInt").Call(
			jen.Id(param.InputVars[0].VarName),
			jen.Lit(10),
			jen.Lit(64),
		)

		renderIfErr(gen)
		gen.Id(param.VarName).Op(":=").Id(param.TypeName).Call(jen.Id(tempName))

	case "uint", "uint8", "uint16", "uint32", "uint64":
		tempName := param.VarName + "Uint64"

		gen.List(jen.Id(tempName), jen.Id("err")).Op(":=").
			Qual(pkgStrconv, "ParseUint").Call(
			jen.Id(param.InputVars[0].VarName),
			jen.Lit(10),
			jen.Lit(64),
		)

		renderIfErr(gen)
		gen.Id(param.VarName).Op(":=").Id(param.TypeName).Call(jen.Id(tempName))

	case "bool":
		gen.List(jen.Id(param.VarName), jen.Id("err")).
			Op(":=").
			Qual(pkgStrconv, "ParseBool").
			Call(jen.Id(param.InputVars[0].VarName))

		renderIfErr(gen)
	}

}

func renderPayloadParam(gen *jen.Group, param InputParam) {
	gen.Defer().Id("r").Dot("Body").Dot("Close").Call()
	gen.Var().Id(param.VarName).Id(param.TypeName)
	gen.Id("err").Op("=").
		Qual(pkgJson, "NewDecoder").Call(jen.Id("r").Dot("Body")).
		Dot("Decode").Call(jen.Op("&").Id(param.VarName))
	renderIfErr(gen)
}

func renderIfErr(gen *jen.Group) {
	gen.If(jen.Id("err").Op("!=").Nil()).Block(jen.Return().Id("err"))
}
