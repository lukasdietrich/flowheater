package main

import (
	"strings"

	"github.com/dave/jennifer/jen"
)

const (
	pkgHttp    = "net/http"
	pkgChi     = "github.com/go-chi/chi"
	pkgStrconv = "strconv"
	pkgJson    = "encoding/json"
	pkgLog     = "log"
)

var (
	genRouter         = "ServiceRouter"
	genWrapError      = "wrapError"
	genRouterReceiver = jen.Id("s").Op("*").Id(genRouter)

	genCustomError    = "HandleError"
	genCustomRequest  = "ReadRequest"
	genCustomResponse = "WriteResponse"
)

func RenderServiceRouter(filename string, collection *ServiceCollection) error {
	renderer := jen.NewFile(collection.PackageName)
	renderer.HeaderComment("Code generated by flowheater. DO NOT EDIT.")

	for _, part := range []jen.Code{
		renderCustomFuncTypes(),
		renderRouterStruct(collection),
		renderRouterHandler(collection),
		renderErrorHandler(),
		renderRouterEndpoints(collection),
	} {
		renderer.Add(part).Line()
	}

	return renderer.Save(filename)
}

func renderCustomFuncTypes() jen.Code {
	var types []jen.Code

	if customErrorHandler {
		types = append(types,
			jen.Type().Id(genCustomError+"Func").Func().
				Params(
					jen.Qual(pkgHttp, "ResponseWriter"),
					jen.Op("*").Qual(pkgHttp, "Request"),
					jen.Id("error"),
				).
				Line(),
		)
	}

	if customRequestReader {
		types = append(types,
			jen.Type().Id(genCustomRequest+"Func").Func().
				Params(
					jen.Op("*").Qual(pkgHttp, "Request"),
					jen.Interface(),
				).
				Params(jen.Id("error")).
				Line(),
		)
	}

	if customResponseWriter {
		types = append(types,
			jen.Type().Id(genCustomResponse+"Func").Func().
				Params(
					jen.Qual(pkgHttp, "ResponseWriter"),
					jen.Op("*").Qual(pkgHttp, "Request"),
					jen.Interface(),
				).
				Params(jen.Id("error")).
				Line(),
		)
	}

	return jen.Add(types...)
}

func renderRouterStruct(c *ServiceCollection) jen.Code {
	return jen.
		Comment(genRouter + " is a collection of services that are").Line().
		Comment("orchestrated into a net/http.Handler.").Line().
		Type().
		Id(genRouter).
		StructFunc(func(g *jen.Group) {
			for _, service := range c.Services {
				g.Id(service.TypeName).Op("*").Id(service.TypeName)
			}

			for _, resolver := range c.Resolvers {
				g.Id(resolver.TypeName).Op("*").Id(resolver.TypeName)
			}

			if customErrorHandler {
				g.Id(genCustomError).Id(genCustomError + "Func")
			}

			if customRequestReader {
				g.Id(genCustomRequest).Id(genCustomRequest + "Func")
			}

			if customResponseWriter {
				g.Id(genCustomResponse).Id(genCustomResponse + "Func")
			}
		})
}

func renderRouterHandler(c *ServiceCollection) jen.Code {
	return jen.
		Comment("Handler creates a new net/http.Handler for all the").Line().
		Comment("service endpoints.").Line().
		Func().
		Params(genRouterReceiver).
		Id("Handler").
		Params().
		Qual(pkgHttp, "Handler").
		BlockFunc(func(gen *jen.Group) {
			// h := chi.NewRouter()
			gen.Id("h").Op(":=").Qual(pkgChi, "NewRouter").Call()
			gen.Line()

			for _, service := range c.Services {
				gen.Id("h").Dot("Route").CallFunc(renderRouterRegisterService(service))
				gen.Line()
			}

			// return h
			gen.Return(jen.Id("h"))
		})
}

func renderRouterRegisterService(service *Service) func(*jen.Group) {
	return func(gen *jen.Group) {
		gen.Lit(service.Path)
		gen.Func().Params(jen.Id("r").Qual(pkgChi, "Router")).
			BlockFunc(func(g *jen.Group) {
				for _, endpoint := range service.Endpoints {
					m := strings.Title(strings.ToLower(endpoint.HttpMethod))
					g.Id("r").Dot(m).Call(
						jen.Lit(endpoint.Path),
						jen.Id("s").Dot(genWrapError).Call(
							jen.Id("s").Dot(endpoint.WrapperFunc()),
						),
					)
				}
			})
	}
}

func renderErrorHandler() jen.Code {
	return jen.
		Comment(genWrapError + " wraps a handler to conform with http.HandlerFunc.").Line().
		Func().
		Params(genRouterReceiver).
		Id(genWrapError).
		Params(
			jen.Id("fn").
				Func().
				Params(
					jen.Qual(pkgHttp, "ResponseWriter"),
					jen.Op("*").Qual(pkgHttp, "Request"),
				).
				Params(jen.Id("error")),
		).
		Params(jen.Qual(pkgHttp, "HandlerFunc")).
		Block(
			jen.Return().
				Func().
				Params(
					jen.Id("w").Qual(pkgHttp, "ResponseWriter"),
					jen.Id("r").Op("*").Qual(pkgHttp, "Request"),
				).
				Block(
					jen.If(
						jen.Id("err").Op(":=").Id("fn").Call(
							jen.Id("w"),
							jen.Id("r"),
						),
						jen.Id("err").Op("!=").Nil(),
					).BlockFunc(func(gen *jen.Group) {
						if customErrorHandler {
							gen.Id("s").Dot(genCustomError).Call(
								jen.Id("w"),
								jen.Id("r"),
								jen.Id("err"),
							)
						} else {
							gen.Qual(pkgLog, "Printf").
								Call(
									jen.Lit("%s %s: %v"),
									jen.Id("r").Dot("Method"),
									jen.Id("r").Dot("URL").Dot("Path"),
									jen.Id("err"),
								)
							gen.Id("w").Dot("WriteHeader").
								Call(jen.Qual(pkgHttp, "StatusInternalServerError"))
						}
					}),
				),
		)
}

func renderRouterEndpoints(c *ServiceCollection) jen.Code {
	var funcs jen.Statement

	for _, service := range c.Services {
		for _, endpoint := range service.Endpoints {
			funcs.Add(renderEndpointWrapper(endpoint))
		}
	}

	return &funcs
}

func renderEndpointWrapper(endpoint *Endpoint) jen.Code {
	// func (s *ServiceRouter) func _handle_<Service>_<Endpoint>(
	//   w http.ResponseWriter,
	//   r *http.Request,
	// ) { ... }
	return jen.
		Commentf("%s wraps the endpoint %s#%s.",
			endpoint.WrapperFunc(),
			endpoint.Service.TypeName,
			endpoint.FuncName,
		).Line().
		Func().
		Params(genRouterReceiver).
		Id(endpoint.WrapperFunc()).
		Params(
			jen.Id("w").Qual(pkgHttp, "ResponseWriter"),
			jen.Id("r").Op("*").Qual(pkgHttp, "Request"),
		).
		Params(jen.Id("error")).
		BlockFunc(renderEndpointWrapperBody(endpoint)).
		Line()
}

func renderEndpointWrapperBody(endpoint *Endpoint) func(*jen.Group) {
	return func(gen *jen.Group) {
		gen.Defer().Id("r").Dot("Body").Dot("Close").Call()

		for _, param := range endpoint.InputParams {
			// param0 := chi.URLParam("<paramName>")
			renderInputParam(gen, param)
		}

		if len(endpoint.InputParams) > 0 {
			gen.Line()
		}

		// s.<Service>.<Endpoint>(<Params>...)
		callFunc := jen.Id("s").
			Dot(endpoint.Service.TypeName).
			Dot(endpoint.FuncName).
			Call(renderInputVars(endpoint.InputVars))

		if !endpoint.ReturnsError && !endpoint.ReturnsValue {
			gen.Add(callFunc)
			gen.Return().Nil()
		} else if endpoint.ReturnsError && !endpoint.ReturnsValue {
			gen.Return().Add(callFunc)
		} else {
			gen.
				ListFunc(func(gen *jen.Group) {
					if endpoint.ReturnsValue {
						gen.Id("val")
					}

					if endpoint.ReturnsError {
						gen.Id("err")
					}
				}).
				Op(":=").
				Add(callFunc)

			if endpoint.ReturnsError {
				renderIfErr(gen)
			}

			if customResponseWriter {
				gen.Return().
					Id("s").Dot(genCustomResponse).Call(
					jen.Id("w"),
					jen.Id("r"),
					jen.Op("&").Id("val"),
				)
			} else {
				gen.Return().
					Qual(pkgJson, "NewEncoder").Call(jen.Id("w")).
					Dot("Encode").Call(jen.Op("&").Id("val"))
			}
		}
	}
}

func renderInputParam(gen *jen.Group, param InputParam) {
	switch param.ParamKind {
	case KindStringParam:
		renderStringParam(gen, param)

	case KindConvertParam:
		renderConvertParam(gen, param)

	case KindPayloadParam:
		renderPayloadParam(gen, param)

	case KindResolveParam:
		renderResolverParam(gen, param)
	}

	gen.Line()
}

func renderStringParam(gen *jen.Group, param InputParam) {
	gen.Commentf("Extract url parameter %s.", param.ParamName)
	gen.Id(param.VarName).Op(":=").Qual(pkgChi, "URLParam").Call(
		jen.Id("r"),
		jen.Lit(param.ParamName),
	)
}

func renderConvertParam(gen *jen.Group, param InputParam) {
	stringVar := param.InputVars[0]

	gen.Commentf("Convert %s to %s.", stringVar.VarName, param.TypeName)

	switch param.TypeName {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64":

		var (
			unsizedType = strings.TrimRight(param.TypeName, "123468")
			parseFunc   = "Parse" + strings.Title(unsizedType)
			tempName    = param.VarName + "b64"
		)

		gen.List(jen.Id(tempName), jen.Id("err")).
			Op(":=").
			Qual(pkgStrconv, parseFunc).
			Call(jen.Id(stringVar.VarName), jen.Lit(10), jen.Lit(64))

		renderIfErr(gen)
		gen.Id(param.VarName).Op(":=").Id(param.TypeName).Call(jen.Id(tempName))

	case "bool":
		gen.List(jen.Id(param.VarName), jen.Id("err")).
			Op(":=").
			Qual(pkgStrconv, "ParseBool").
			Call(jen.Id(stringVar.VarName))

		renderIfErr(gen)
	}
}

func renderPayloadParam(gen *jen.Group, param InputParam) {
	gen.Var().Id(param.VarName).Id(param.TypeName)

	var decoderCall jen.Code

	if customRequestReader {
		decoderCall = jen.Id("s").Dot(genCustomRequest).Call(
			jen.Id("r"),
			jen.Op("&").Id(param.VarName),
		)
	} else {
		decoderCall = jen.
			Qual(pkgJson, "NewDecoder").Call(jen.Id("r").Dot("Body")).
			Dot("Decode").Call(jen.Op("&").Id(param.VarName))
	}

	gen.If(
		jen.Id("err").Op(":=").Add(decoderCall),
		jen.Id("err").Op("!=").Nil(),
	).Block(jen.Return().Id("err"))
}

func renderResolverParam(gen *jen.Group, param InputParam) {
	gen.Commentf("Resolve parameter using %s.", param.Resolver)

	var stmt jen.Code

	if param.ReturnsError {
		stmt = jen.List(jen.Id(param.VarName), jen.Id("err"))
	} else {
		stmt = jen.Id(param.VarName)
	}

	gen.Add(stmt).
		Op(":=").
		Id("s").Dot(param.Resolver).Dot(mResolve).
		Call(renderInputVars(param.InputVars))

	if param.ReturnsError {
		renderIfErr(gen)
	}
}

func renderIfErr(gen *jen.Group) {
	gen.If(jen.Id("err").Op("!=").Nil()).Block(jen.Return().Id("err"))
}

func renderInputVars(inputVars []InputVar) jen.Code {
	var varsCode []jen.Code

	for _, inputVar := range inputVars {
		var prefix string
		if n := inputVar.PointerDepth; n > 0 {
			prefix = strings.Repeat("&", n)
		} else {
			prefix = strings.Repeat("*", -n)
		}

		varsCode = append(varsCode, jen.Id(prefix+inputVar.VarName))
	}

	return jen.List(varsCode...)
}
