package main

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
)

const (
	pHttp = "net/http"
	pChi  = "github.com/go-chi/chi"
)

var (
	jPtr            = "*"
	jRouter         = "ServiceRouter"
	jRouterReceiver = jen.Id("s").Op(jPtr).Id(jRouter)
)

func RenderServiceRouter(filename string, collection *ServiceCollection) error {
	gen := jen.NewFile(collection.PackageName)
	gen.HeaderComment("Code generated by flowheater. DO NOT EDIT.")

	renderRouterStruct(gen, collection)
	renderRouterHandler(gen, collection)
	renderRouterEndpoints(gen, collection)

	return gen.Save(filename)
}

func renderRouterStruct(gen *jen.File, c *ServiceCollection) {
	gen.Comment(jRouter + " is a collection of services that are").Line().
		Comment("orchestrated into a net/http.Handler.").Line().
		Type().
		Id(jRouter).
		StructFunc(func(g *jen.Group) {
			for _, service := range c.Services {
				g.Id(service.TypeName).Op(jPtr).Id(service.TypeName)
			}
		})
}

func renderRouterHandler(gen *jen.File, c *ServiceCollection) {
	gen.Comment("Handler creates a new net/http.Handler for all the").Line().
		Comment("service endpoints.").Line().
		Func().
		Params(jRouterReceiver).
		Id("Handler").
		Params().
		Qual(pHttp, "Handler").
		BlockFunc(func(gen *jen.Group) {
			// h := chi.NewRouter()
			gen.Id("h").Op(":=").Qual(pChi, "NewRouter").Call()
			gen.Line()

			for _, service := range c.Services {
				gen.Id("h").Op(".").Id("Route").
					CallFunc(renderRouterRegisterService(service))
				gen.Line()
			}

			// return h
			gen.Return(jen.Id("h"))
		})
}

func renderRouterRegisterService(service *Service) func(*jen.Group) {
	return func(gen *jen.Group) {
		gen.Lit(service.Path)
		gen.Func().Params(jen.Id("r").Qual(pChi, "Router")).
			BlockFunc(func(g *jen.Group) {
				for _, endpoint := range service.Endpoints {
					m := strings.Title(strings.ToLower(endpoint.HttpMethod))
					g.Id("r").Op(".").Id(m).Call(
						jen.Lit(endpoint.Path),
						jen.Id("s").Op(".").Id(endpoint.WrapperFunc()),
					)
				}
			})
	}
}

func renderRouterEndpoints(gen *jen.File, c *ServiceCollection) {
	for _, service := range c.Services {
		for _, endpoint := range service.Endpoints {
			renderEndpointWrapper(gen, endpoint)
		}
	}
}

func renderEndpointWrapper(gen *jen.File, endpoint *Endpoint) {
	comment := fmt.Sprintf("%s wraps the endpoint %s#%s.",
		endpoint.WrapperFunc(), endpoint.Service.TypeName, endpoint.FuncName)

	// func (s *ServiceRouter) func _handle_<Service>_<Endpoint>(
	//   w http.ResponseWriter,
	//   r *http.Request,
	// ) { ... }
	gen.Comment(comment).Line().
		Func().
		Params(jRouterReceiver).
		Id(endpoint.WrapperFunc()).
		Params(
			jen.Id("w").Qual(pHttp, "ResponseWriter"),
			jen.Id("r").Op(jPtr).Qual(pHttp, "Request"),
		).
		BlockFunc(renderEndpointWrapperBody(endpoint))

}

func renderEndpointWrapperBody(endpoint *Endpoint) func(*jen.Group) {
	return func(gen *jen.Group) {
		for _, resolver := range endpoint.Resolvers {
			// param0 := chi.URLParam("<paramName>")
			renderResolver(gen, resolver)
		}

		if len(endpoint.Resolvers) > 0 {
			gen.Line()
		}

		// s.<Service>.<Endpoint>(<Params>...)
		gen.Id("s").
			Op(".").Id(endpoint.Service.TypeName).
			Op(".").Id(endpoint.FuncName).
			CallFunc(func(gen *jen.Group) {
				for _, param := range endpoint.Params {
					gen.Id(param)
				}
			})
	}
}

func renderResolver(gen *jen.Group, resolver Resolver) {
	switch resolver.TypeName {
	case "string":
		gen.Id(resolver.VarName).Op(":=").Qual(pChi, "URLParam").Call(
			jen.Id("r"),
			jen.Lit(resolver.ParamName),
		)
	}
}
