package main

import (
	"fmt"

	"github.com/dave/jennifer/jen"
)

const (
	pHttp = "net/http"
	pChi  = "github.com/go-chi/chi"
)

var (
	jPtr            = "*"
	jRouter         = "ServiceRouter"
	jRouterReceiver = jen.Id("s").Op(jPtr).Id(jRouter)
)

func RenderServiceRouter(filename string, collection *ServiceCollection) error {
	gen := jen.NewFile(collection.PackageName)
	gen.HeaderComment("Code generated by flowheater. DO NOT EDIT.")

	renderRouterStruct(gen, collection)
	renderRouterHandler(gen, collection)
	renderRouterEndpoints(gen, collection)

	return gen.Save(filename)
}

func renderRouterStruct(gen *jen.File, c *ServiceCollection) {
	gen.Comment(jRouter + " is a collection of services that are").Line().
		Comment("orchestrated into a net/http.Handler.").Line().
		Type().
		Id(jRouter).
		StructFunc(func(g *jen.Group) {
			for _, service := range c.Services {
				g.Id(service.TypeName).Op(jPtr).Id(service.TypeName)
			}
		})
}

func renderRouterHandler(gen *jen.File, c *ServiceCollection) {
	gen.Comment("Handler creates a new net/http.Handler for all the").Line().
		Comment("service endpoints.").Line().
		Func().
		Params(jRouterReceiver).
		Id("Handler").
		Params().
		Qual(pHttp, "Handler").
		BlockFunc(func(g *jen.Group) {
			g.Id("h").Op(":=").Qual(pChi, "NewRouter").Call()
			g.Line()

			for _, service := range c.Services {
				g.Id("h").Op(".").Id("Route").Call(
					jen.Lit(service.Path),
					jen.Func().Params(jen.Id("r").Qual(pChi, "Router")).
						BlockFunc(func(g *jen.Group) {
							for _, endpoint := range service.Endpoints {
								g.Id("r").Op(".").Id("Get").Call(
									jen.Lit(endpoint.Path),
									jen.Id("s").Op(".").Id(endpoint.WrapperFunc()),
								)
							}
						}),
				)

				g.Line()
			}

			g.Return(jen.Id("h"))
		})
}

func renderRouterEndpoints(gen *jen.File, c *ServiceCollection) {
	for _, service := range c.Services {
		for _, endpoint := range service.Endpoints {
			renderEndpointWrapper(gen, endpoint)
		}
	}
}

func renderEndpointWrapper(gen *jen.File, endpoint *Endpoint) {
	comment := fmt.Sprintf("%s wraps the endpoint %s#%s.",
		endpoint.WrapperFunc(), endpoint.Service.TypeName, endpoint.FuncName)

	gen.
		Comment(comment).Line().
		Func().
		Params(jRouterReceiver).
		Id(endpoint.WrapperFunc()).
		ParamsFunc(func(g *jen.Group) {
			g.Id("w").Qual(pHttp, "ResponseWriter")
			g.Id("r").Op(jPtr).Qual(pHttp, "Request")
		}).
		BlockFunc(func(g *jen.Group) {
			for _, resolver := range endpoint.Resolvers {
				renderResolver(g, resolver)
			}

			if len(endpoint.Resolvers) > 0 {
				g.Line()
			}

			g.
				Id("s").
				Op(".").
				Id(endpoint.Service.TypeName).
				Op(".").
				Id(endpoint.FuncName).
				CallFunc(func(g *jen.Group) {
					for _, param := range endpoint.Params {
						g.Id(param)
					}
				})
		})

}

func renderResolver(gen *jen.Group, resolver Resolver) {
	switch resolver.TypeName {
	case "string":
		gen.Id(resolver.VarName).Op(":=").Qual(pChi, "URLParam").Call(
			jen.Id("r"),
			jen.Lit(resolver.VarName),
		)
	}
}
